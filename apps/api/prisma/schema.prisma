generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  PLATFORM_ADMIN
  TENANT_OWNER
  TENANT_ADMIN
  TENANT_GUIDE
  VISITOR
}

enum UserStatus {
  ACTIVE
  SUSPENDED
}

enum TenantType {
  COMPANY
  GUIDE_OWNED
}

enum TenantStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum MembershipRole {
  TENANT_OWNER
  TENANT_ADMIN
  TENANT_GUIDE
}

enum ActivityType {
  HIKING
  CAMPING
}

enum LocationStatus {
  DRAFT
  ACTIVE
  INACTIVE
}

enum Difficulty {
  EASY
  MODERATE
  HARD
}

enum Accessibility {
  CAR_ACCESSIBLE
  REMOTE
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  SUSPENDED
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum OrganizerApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum NotificationType {
  REQUEST_UPDATE
  SYSTEM
  EVENT
}

enum ProductStatus {
  DRAFT
  ACTIVE
  INACTIVE
}

model User {
  id                    String                   @id @default(uuid())
  email                 String                   @unique
  passwordHash          String
  role                  UserRole                 @default(VISITOR)
  status                UserStatus               @default(ACTIVE)
  emailVerifiedAt       DateTime?
  createdAt             DateTime                 @default(now())
  updatedAt             DateTime                 @updatedAt
  profile               Profile?
  ownedTenants          Tenant[]                 @relation("TenantOwner")
  memberships           TenantMembership[]
  createdEvents         Event[]                  @relation("EventCreator")
  guidedEvents          Event[]                  @relation("EventGuide")
  requests              EventRequest[]
  participants          EventParticipant[]
  notifications         Notification[]
  refreshTokens         RefreshToken[]
  mediaAssets           MediaAsset[]
  auditLogs             AuditLog[]               @relation("AuditActor")
  emailVerification     EmailVerificationToken[]
  passwordReset         PasswordResetToken[]
  organizerApplications OrganizerApplication[]   @relation("ApplicationApplicant")
  reviewedApplications  OrganizerApplication[]   @relation("ApplicationReviewer")
  reviewedRequests      EventRequest[]           @relation("RequestReviewer")
  reviewedByParticipants EventParticipant[]      @relation("ParticipantReviewer")
  sentMessages           ChatMessage[]            @relation("SentMessages")
  receivedMessages       ChatMessage[]            @relation("ReceivedMessages")
  merchantProfile        MerchantProfile?
  submittedLocations     Location[]               @relation("SubmittedLocations")
}

model Profile {
  id          String  @id @default(uuid())
  userId      String  @unique
  displayName String?
  phone       String?
  bio         String?
  avatarUrl   String?
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Tenant {
  id                    String                 @id @default(uuid())
  name                  String
  slug                  String                 @unique
  type                  TenantType
  status                TenantStatus           @default(PENDING)
  ownerId               String
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  owner                 User                   @relation("TenantOwner", fields: [ownerId], references: [id])
  memberships           TenantMembership[]
  events                Event[]
  mediaAssets           MediaAsset[]
  organizerApplications OrganizerApplication[]
  auditLogs             AuditLog[]
}

model TenantMembership {
  id        String         @id @default(uuid())
  tenantId  String
  userId    String
  role      MembershipRole
  createdAt DateTime       @default(now())
  tenant    Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tenantId, userId])
}

model OrganizerApplication {
  id                 String                     @id @default(uuid())
  applicantId        String
  requestedTenantId  String?
  requestedName      String
  requestedSlug      String
  requestedType      TenantType
  status             OrganizerApplicationStatus @default(PENDING)
  reviewerId         String?
  reviewerNote       String?
  reviewedAt         DateTime?
  createdAt          DateTime                   @default(now())
  updatedAt          DateTime                   @updatedAt
  applicant          User                       @relation("ApplicationApplicant", fields: [applicantId], references: [id], onDelete: Cascade)
  requestedTenant    Tenant?                    @relation(fields: [requestedTenantId], references: [id])
  reviewer           User?                      @relation("ApplicationReviewer", fields: [reviewerId], references: [id])
}

model Location {
  id            String         @id @default(uuid())
  name          String
  region        String
  activityType  ActivityType
  description   String
  difficulty    Difficulty?
  season        String[]
  childFriendly Boolean        @default(false)
  maxGroupSize  Int?
  accessibility Accessibility?
  images        String[]
  featured      Boolean        @default(false)
  status        LocationStatus @default(ACTIVE)
  distance      Float?
  duration      Float?
  elevation     Int?
  campingType   String?
  latitude      Float?
  longitude     Float?
  highlights    String[]
  submittedById String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  events        Event[]
  submittedBy   User?          @relation("SubmittedLocations", fields: [submittedById], references: [id])
}

model Event {
  id           String      @id @default(uuid())
  tenantId     String
  locationId   String
  createdById  String
  guideId      String?
  title        String
  description  String
  startAt      DateTime
  endAt        DateTime?
  meetingPoint String?
  itinerary    String[]
  requirements String[]
  priceAed     Int         @default(0)
  capacity     Int
  status       EventStatus @default(DRAFT)
  publishedAt  DateTime?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  tenant       Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  location     Location    @relation(fields: [locationId], references: [id])
  createdBy    User        @relation("EventCreator", fields: [createdById], references: [id])
  guide        User?       @relation("EventGuide", fields: [guideId], references: [id])
  requests     EventRequest[]
  participants EventParticipant[]
  chatMessages ChatMessage[]
}

model EventRequest {
  id            String        @id @default(uuid())
  eventId       String
  userId        String
  status        RequestStatus @default(PENDING)
  note          String?
  organizerNote String?
  reviewedById  String?
  reviewedAt    DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  event         Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewedBy    User?         @relation("RequestReviewer", fields: [reviewedById], references: [id])
  participant   EventParticipant?

  @@unique([eventId, userId])
}

model EventParticipant {
  id           String   @id @default(uuid())
  eventId      String
  userId       String
  requestId    String   @unique
  approvedById String
  checkedInAt  DateTime?
  createdAt    DateTime @default(now())
  event        Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  request      EventRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  approvedBy   User     @relation("ParticipantReviewer", fields: [approvedById], references: [id])

  @@unique([eventId, userId])
}

model MediaAsset {
  id           String   @id @default(uuid())
  key          String   @unique
  url          String
  bucket       String
  mimeType     String
  size         Int
  uploadedById String
  tenantId     String?
  kind         String
  createdAt    DateTime @default(now())
  uploadedBy   User     @relation(fields: [uploadedById], references: [id], onDelete: Cascade)
  tenant       Tenant?  @relation(fields: [tenantId], references: [id])
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  title     String
  body      String
  type      NotificationType
  isRead    Boolean          @default(false)
  meta      Json?
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RefreshToken {
  id         String   @id @default(uuid())
  userId     String
  tokenHash  String
  expiresAt  DateTime
  revokedAt  DateTime?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model AuditLog {
  id         String   @id @default(uuid())
  actorId    String
  action     String
  entityType String
  entityId   String
  tenantId   String?
  metadata   Json?
  createdAt  DateTime @default(now())
  actor      User     @relation("AuditActor", fields: [actorId], references: [id], onDelete: Cascade)
  tenant     Tenant?  @relation(fields: [tenantId], references: [id])
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ChatMessage {
  id         String    @id @default(uuid())
  senderId   String
  receiverId String
  eventId    String?
  content    String
  readAt     DateTime?
  createdAt  DateTime  @default(now())
  sender     User      @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User      @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  event      Event?    @relation(fields: [eventId], references: [id])

  @@index([senderId, receiverId])
  @@index([receiverId, readAt])
}

model MerchantProfile {
  id           String    @id @default(uuid())
  userId       String    @unique
  shopName     String
  description  String?
  logo         String?
  contactEmail String?
  contactPhone String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  products     Product[]
}

model Product {
  id              String          @id @default(uuid())
  merchantId      String
  name            String
  description     String?
  images          String[]
  priceAed        Int
  discountPercent Int?
  packagingInfo   String?
  category        String
  status          ProductStatus   @default(DRAFT)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  merchant        MerchantProfile @relation(fields: [merchantId], references: [id], onDelete: Cascade)
}
